---
type: go
---
# [[Go]] [[subtests]]

https://go.dev/blog/subtests

## Control of [[Parallelism]]

A test is called a parallel test if its test function calls the Parallel method on its instance of `testing.T`. A parallel test never runs concurrently with a sequential test and its execution is suspended until its calling test function, that of the parent test, has returned. The `-parallel` flag defines the maximum number of parallel tests that can run in parallel.

### Run a group of tests in parallel

```go
func TestGroupedParallel(t *testing.T) {
    for _, tc := range testCases {
        tc := tc // capture range variable
        t.Run(tc.Name, func(t *testing.T) {
            t.Parallel()
            if got := foo(tc.in); got != tc.out {
                t.Errorf("got %v; want %v", got, tc.out)
            }
            ...
        })
    }
}
```

The outer test will not complete until all parallel tests started by `Run` have completed. As a result, no other parallel tests can run in parallel to these parallel tests.

Note that we need to capture the range variable to ensure that tc gets bound to the correct instance.

### Cleaning up after a group of parallel tests

In the previous example we used the semantics to wait on a group of parallel tests to complete before commencing other tests. The same technique can be used to clean up after a group of parallel tests that share common resources:

```go
func TestTeardownParallel(t *testing.T) {
    // <setup code>
    // This Run will not return until its parallel subtests complete.
    t.Run("group", func(t *testing.T) {
        t.Run("Test1", parallelTest1)
        t.Run("Test2", parallelTest2)
        t.Run("Test3", parallelTest3)
    })
    // <tear-down code>
}
```
The behavior of waiting on a group of parallel tests is identical to that of the previous example.

[//begin]: # "Autogenerated link references for markdown compatibility"
[Go]: go "Go"
[//end]: # "Autogenerated link references"